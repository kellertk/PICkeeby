GAL22V10
PICkeeby

; Pin 1-12 (left side)
/NSIG2 MODE A0 SIG1 /IBFCLRB SIG2 /CSB AUXB CLKOUT NC NC GND
; Pin 13-24 (right side)
NC A0REG IRQB IBF OBF HDATA1 HDATA0 LEIN HDATA5 LEDSTAT /RDDATAB VCC

; ===== ADDRESS DECODE LOGIC =====

; Read Data (A0=0, Read cycle active)
; 6502: CSB=0 & SIG1(R/WB)=1 & SIG2(Phi2)=1 & A0=0
; Z80:  CSB=0 & SIG1(RDB)=0 & A0=0
RDDATAB = /MODE * CSB * SIG1 * SIG2 * /A0
        + MODE * CSB * /SIG1 * /A0

; Read Status (A0=1, Read cycle active)
; 6502: CSB=0 & SIG1(R/WB)=1 & SIG2(Phi2)=1 & A0=1
; Z80:  CSB=0 & SIG1(RDB)=0 & A0=1
LEDSTAT = /MODE * CSB * SIG1 * SIG2 * A0
        + MODE * CSB * /SIG1 * A0

; ===== 373 LATCH ENABLE =====
; 6502: Transparent while Phi2 HIGH, latch on fall
; Z80:  Transparent while WRB LOW, latch on rise
LEIN = /MODE * SIG2
     + MODE * /SIG2

; ===== ASYNCHRONOUS RESET =====
; Clears all registered outputs (IBF, A0_REG) when PIC asserts /IBF_CLR.
; A0_REG is already read before clearing, so resetting it to 0 is harmless.
AR = IBFCLRB

; ===== OBF - COMBINATIONAL SR LATCH =====
; Set when PIC pulses CLK_OUT high, cleared when host reads data port
OBF = CLKOUT * /RDDATAB
    + OBF * /RDDATAB

; ===== IBF - REGISTERED (clocked by /SIG2, async clear via AR) =====
; Captures write condition on /SIG2 rising edge, synchronized with A0_REG.
; Cleared immediately by AR when PIC asserts /IBF_CLR (no clock edge needed).
; 6502 write: CSB=0, R/WB(SIG1)=0, IBFCLRB inactive
; Z80 write:  CSB=0, RDB(SIG1)=1 (not reading), IBFCLRB inactive
IBF.R = /MODE * CSB * /SIG1 * /IBFCLRB
      + MODE * CSB * SIG1 * /IBFCLRB
      + IBF * /IBFCLRB

; ===== A0_REG - REGISTERED (clocked by /SIG2, async clear via AR) =====
; Load/hold mux: captures A0 during write cycles, holds otherwise.
; Also cleared by AR alongside IBF, but PIC has already read it by then.
A0REG.R = A0 * /MODE * CSB * /SIG1
        + A0 * MODE * CSB * SIG1
        + A0REG * /CSB
        + A0REG * /MODE * SIG1
        + A0REG * MODE * /SIG1

; ===== ACTIVE LOW INTERRUPT =====
; IRQB active (low) when output buffer has data.
; Open-drain style: no .T term = macrocell outputs 0 = pin LOW
; when enabled.  Floats when idle so the host bus pull-up holds
; it HIGH.
IRQB.T = GND
IRQB.E = OBF

; ===== STATUS OUTPUTS (ACTIVE HIGH FOR TRI-STATE ENABLE) =====
; Drive status bits onto host data bus during status read
HDATA0.T = OBF
HDATA0.E = LEDSTAT

HDATA1.T = IBF
HDATA1.E = LEDSTAT

; HDATA5 - AUXB status bit (active HIGH = data from Port 2)
HDATA5.T = AUXB
HDATA5.E = LEDSTAT

DESCRIPTION
PICkeeby Dual PS/2 Controller
/SIG2-clocked registered IBF and A0_REG with async reset, combinational OBF
AUXB passed through for Port 2 identification
